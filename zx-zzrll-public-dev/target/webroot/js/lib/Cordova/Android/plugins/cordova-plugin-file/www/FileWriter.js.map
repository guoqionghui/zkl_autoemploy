{"version":3,"sources":["js/lib/Cordova/Android/plugins/cordova-plugin-file/www/FileWriter.js"],"names":["cordova","define","require","exports","module","exec","FileError","ProgressEvent","FileWriter","file","this","fileName","length","localURL","size","position","readyState","result","error","onwritestart","onprogress","onwrite","onwriteend","onabort","onerror","INIT","WRITING","DONE","prototype","abort","INVALID_STATE_ERR","ABORT_ERR","target","write","data","isPendingBlobReadResult","isBinary","that","supportsBinary","window","Blob","ArrayBuffer","isProxySupportBlobNatively","platformId","File","fileReader","FileReader","onload","call","readAsArrayBuffer","readAsText","Array","apply","Uint8Array","me","r","e","seek","offset","Math","max","truncate","min"],"mappings":"AAAAA,QAAQC,OAAO,iCAAkC,SAASC,EAASC,EAASC,GAsB5E,GAAIC,GAAOH,EAAQ,gBACfI,EAAYJ,EAAQ,eACpBK,EAAgBL,EAAQ,mBAaxBM,EAAa,SAASC,GACtBC,KAAKC,SAAW,GAChBD,KAAKE,OAAS,EACVH,IACAC,KAAKG,SAAWJ,EAAKI,UAAYJ,EACjCC,KAAKE,OAASH,EAAKK,MAAQ,GAG/BJ,KAAKK,SAAW,EAEhBL,KAAKM,WAAa,EAElBN,KAAKO,OAAS,KAGdP,KAAKQ,MAAQ,KAGbR,KAAKS,aAAe,KACpBT,KAAKU,WAAa,KAClBV,KAAKW,QAAU,KACfX,KAAKY,WAAa,KAClBZ,KAAKa,QAAU,KACfb,KAAKc,QAAU,KAInBhB,GAAWiB,KAAO,EAClBjB,EAAWkB,QAAU,EACrBlB,EAAWmB,KAAO,EAKlBnB,EAAWoB,UAAUC,MAAQ,WAEzB,GAAInB,KAAKM,aAAeR,EAAWmB,MAAQjB,KAAKM,aAAeR,EAAWiB,KACtE,KAAM,IAAInB,GAAUA,EAAUwB,kBAIlCpB,MAAKQ,MAAQ,GAAIZ,GAAUA,EAAUyB,WAErCrB,KAAKM,WAAaR,EAAWmB,KAGD,kBAAjBjB,MAAKa,SACZb,KAAKa,QAAQ,GAAIhB,GAAc,SAAUyB,OAAStB,QAIvB,kBAApBA,MAAKY,YACZZ,KAAKY,WAAW,GAAIf,GAAc,YAAayB,OAAStB,SAUhEF,EAAWoB,UAAUK,MAAQ,SAASC,EAAMC,GAExC,GAGIC,GAHAC,EAAK3B,KACL4B,EAAyC,mBAAhBC,QAAOC,MAAsD,mBAAvBD,QAAOE,YACtEC,EAAqD,aAAvB1C,QAAQ2C,YAAoD,YAAvB3C,QAAQ2C,UAI/E,IAAIT,YAAgBU,QAAUF,GAA8BJ,GAAkBJ,YAAgBM,MAAO,CACjG,GAAIK,GAAa,GAAIC,WA+BrB,OA9BAD,GAAWE,OAAS,WAEhBvC,EAAWoB,UAAUK,MAAMe,KAAKX,EAAM3B,KAAKO,QAAQ,IAEvD4B,EAAWrB,QAAU,WAEjBa,EAAKrB,WAAaR,EAAWmB,KAG7BU,EAAKnB,MAAQR,KAAKQ,MAGU,kBAAjBmB,GAAKb,SACZa,EAAKb,QAAQ,GAAIjB,GAAc,SAAUyB,OAASK,KAIvB,kBAApBA,GAAKf,YACZe,EAAKf,WAAW,GAAIf,GAAc,YAAayB,OAASK,MAKhE3B,KAAKM,WAAaR,EAAWkB,aAEzBY,EACAO,EAAWI,kBAAkBf,GAE7BW,EAAWK,WAAWhB,IAa9B,GAPAE,EAAWE,GAAmBJ,YAAgBO,aAC1CL,GAAmC,iBAAvBpC,QAAQ2C,aAEpBT,EAAOiB,MAAMC,MAAM,KAAM,GAAIC,YAAWnB,KAIxCxB,KAAKM,aAAeR,EAAWkB,UAAYS,EAC3C,KAAM,IAAI7B,GAAUA,EAAUwB,kBAIlCpB,MAAKM,WAAaR,EAAWkB,OAE7B,IAAI4B,GAAK5C,IAGsB,mBAApB4C,GAAGnC,cACVmC,EAAGnC,aAAa,GAAIZ,GAAc,cAAeyB,OAASsB,KAI9DjD,EAEI,SAASkD,GAEDD,EAAGtC,aAAeR,EAAWmB,OAKjC2B,EAAGvC,UAAYwC,EAGfD,EAAG1C,OAAS0C,EAAGvC,SAGfuC,EAAGtC,WAAaR,EAAWmB,KAGD,kBAAf2B,GAAGjC,SACViC,EAAGjC,QAAQ,GAAId,GAAc,SAAUyB,OAASsB,KAIvB,kBAAlBA,GAAGhC,YACVgC,EAAGhC,WAAW,GAAIf,GAAc,YAAayB,OAASsB,OAI9D,SAASE,GAEDF,EAAGtC,aAAeR,EAAWmB,OAKjC2B,EAAGtC,WAAaR,EAAWmB,KAG3B2B,EAAGpC,MAAQ,GAAIZ,GAAUkD,GAGC,kBAAfF,GAAG9B,SACV8B,EAAG9B,QAAQ,GAAIjB,GAAc,SAAUyB,OAASsB,KAIvB,kBAAlBA,GAAGhC,YACVgC,EAAGhC,WAAW,GAAIf,GAAc,YAAayB,OAASsB,OAE3D,OAAQ,SAAU5C,KAAKG,SAAUqB,EAAMxB,KAAKK,SAAUqB,KAYjE5B,EAAWoB,UAAU6B,KAAO,SAASC,GAEjC,GAAIhD,KAAKM,aAAeR,EAAWkB,QAC/B,KAAM,IAAIpB,GAAUA,EAAUwB,oBAG7B4B,GAAqB,IAAXA,KAKXA,EAAS,EACThD,KAAKK,SAAW4C,KAAKC,IAAIF,EAAShD,KAAKE,OAAQ,GAI1C8C,EAAShD,KAAKE,OACnBF,KAAKK,SAAWL,KAAKE,OAKrBF,KAAKK,SAAW2C,IASxBlD,EAAWoB,UAAUiC,SAAW,SAAS/C,GAErC,GAAIJ,KAAKM,aAAeR,EAAWkB,QAC/B,KAAM,IAAIpB,GAAUA,EAAUwB,kBAIlCpB,MAAKM,WAAaR,EAAWkB,OAE7B,IAAI4B,GAAK5C,IAGsB,mBAApB4C,GAAGnC,cACVmC,EAAGnC,aAAa,GAAIZ,GAAc,cAAeyB,OAAStB,QAI9DL,EAEI,SAASkD,GAEDD,EAAGtC,aAAeR,EAAWmB,OAKjC2B,EAAGtC,WAAaR,EAAWmB,KAG3B2B,EAAG1C,OAAS2C,EACZD,EAAGvC,SAAW4C,KAAKG,IAAIR,EAAGvC,SAAUwC,GAGV,kBAAfD,GAAGjC,SACViC,EAAGjC,QAAQ,GAAId,GAAc,SAAUyB,OAASsB,KAIvB,kBAAlBA,GAAGhC,YACVgC,EAAGhC,WAAW,GAAIf,GAAc,YAAayB,OAASsB,OAI9D,SAASE,GAEDF,EAAGtC,aAAeR,EAAWmB,OAKjC2B,EAAGtC,WAAaR,EAAWmB,KAG3B2B,EAAGpC,MAAQ,GAAIZ,GAAUkD,GAGC,kBAAfF,GAAG9B,SACV8B,EAAG9B,QAAQ,GAAIjB,GAAc,SAAUyB,OAASsB,KAIvB,kBAAlBA,GAAGhC,YACVgC,EAAGhC,WAAW,GAAIf,GAAc,YAAayB,OAASsB,OAE3D,OAAQ,YAAa5C,KAAKG,SAAUC,KAG/CV,EAAOD,QAAUK","file":"js/lib/Cordova/Android/plugins/cordova-plugin-file/www/FileWriter.js","sourcesContent":["cordova.define(\"cordova-plugin-file.FileWriter\", function(require, exports, module) {\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar exec = require('cordova/exec'),\n    FileError = require('./FileError'),\n    ProgressEvent = require('./ProgressEvent');\n\n/**\n * This class writes to the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To write to the SD card, the file name is \"sdcard/my_file.txt\"\n *\n * @constructor\n * @param file {File} File object containing file properties\n * @param append if true write to the end of the file, otherwise overwrite the file\n */\nvar FileWriter = function(file) {\n    this.fileName = \"\";\n    this.length = 0;\n    if (file) {\n        this.localURL = file.localURL || file;\n        this.length = file.size || 0;\n    }\n    // default is to write at the beginning of the file\n    this.position = 0;\n\n    this.readyState = 0; // EMPTY\n\n    this.result = null;\n\n    // Error\n    this.error = null;\n\n    // Event handlers\n    this.onwritestart = null;   // When writing starts\n    this.onprogress = null;     // While writing the file, and reporting partial file data\n    this.onwrite = null;        // When the write has successfully completed.\n    this.onwriteend = null;     // When the request has completed (either in success or failure).\n    this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.\n    this.onerror = null;        // When the write has failed (see errors).\n};\n\n// States\nFileWriter.INIT = 0;\nFileWriter.WRITING = 1;\nFileWriter.DONE = 2;\n\n/**\n * Abort writing file.\n */\nFileWriter.prototype.abort = function() {\n    // check for invalid state\n    if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // set error\n    this.error = new FileError(FileError.ABORT_ERR);\n\n    this.readyState = FileWriter.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === \"function\") {\n        this.onabort(new ProgressEvent(\"abort\", {\"target\":this}));\n    }\n\n    // If write end callback\n    if (typeof this.onwriteend === \"function\") {\n        this.onwriteend(new ProgressEvent(\"writeend\", {\"target\":this}));\n    }\n};\n\n/**\n * Writes data to the file\n *\n * @param data text or blob to be written\n * @param isPendingBlobReadResult {Boolean} true if the data is the pending blob read operation result\n */\nFileWriter.prototype.write = function(data, isPendingBlobReadResult) {\n\n    var that=this;\n    var supportsBinary = (typeof window.Blob !== 'undefined' && typeof window.ArrayBuffer !== 'undefined');\n    var isProxySupportBlobNatively = (cordova.platformId === \"windows8\" || cordova.platformId === \"windows\");\n    var isBinary;\n\n    // Check to see if the incoming data is a blob\n    if (data instanceof File || (!isProxySupportBlobNatively && supportsBinary && data instanceof Blob)) {\n        var fileReader = new FileReader();\n        fileReader.onload = function() {\n            // Call this method again, with the arraybuffer as argument\n            FileWriter.prototype.write.call(that, this.result, true /* isPendingBlobReadResult */);\n        };\n        fileReader.onerror = function () {\n            // DONE state\n            that.readyState = FileWriter.DONE;\n\n            // Save error\n            that.error = this.error;\n\n            // If onerror callback\n            if (typeof that.onerror === \"function\") {\n                that.onerror(new ProgressEvent(\"error\", {\"target\":that}));\n            }\n\n            // If onwriteend callback\n            if (typeof that.onwriteend === \"function\") {\n                that.onwriteend(new ProgressEvent(\"writeend\", {\"target\":that}));\n            }\n        };\n\n        // WRITING state\n        this.readyState = FileWriter.WRITING;\n\n        if (supportsBinary) {\n            fileReader.readAsArrayBuffer(data);\n        } else {\n            fileReader.readAsText(data);\n        }\n        return;\n    }\n\n    // Mark data type for safer transport over the binary bridge\n    isBinary = supportsBinary && (data instanceof ArrayBuffer);\n    if (isBinary && cordova.platformId === \"windowsphone\") {\n        // create a plain array, using the keys from the Uint8Array view so that we can serialize it\n        data = Array.apply(null, new Uint8Array(data));\n    }\n    \n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING && !isPendingBlobReadResult) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":me}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // position always increases by bytes written because file would be extended\n            me.position += r;\n            // The length of the file is now where we are done writing.\n\n            me.length = me.position;\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"write\", [this.localURL, data, this.position, isBinary]);\n};\n\n/**\n * Moves the file pointer to the location specified.\n *\n * If the offset is a negative number the position of the file\n * pointer is rewound.  If the offset is greater than the file\n * size the position is set to the end of the file.\n *\n * @param offset is the location to move the file pointer to.\n */\nFileWriter.prototype.seek = function(offset) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    if (!offset && offset !== 0) {\n        return;\n    }\n\n    // See back from end of file.\n    if (offset < 0) {\n        this.position = Math.max(offset + this.length, 0);\n    }\n    // Offset is bigger than file size so set position\n    // to the end of the file.\n    else if (offset > this.length) {\n        this.position = this.length;\n    }\n    // Offset is between 0 and file size so set the position\n    // to start writing.\n    else {\n        this.position = offset;\n    }\n};\n\n/**\n * Truncates the file to the size specified.\n *\n * @param size to chop the file at.\n */\nFileWriter.prototype.truncate = function(size) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":this}));\n    }\n\n    // Write file\n    exec(\n        // Success callback\n        function(r) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Update the length of the file\n            me.length = r;\n            me.position = Math.min(me.position, r);\n\n            // If onwrite callback\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        },\n        // Error callback\n        function(e) {\n            // If DONE (cancelled), then don't do anything\n            if (me.readyState === FileWriter.DONE) {\n                return;\n            }\n\n            // DONE state\n            me.readyState = FileWriter.DONE;\n\n            // Save error\n            me.error = new FileError(e);\n\n            // If onerror callback\n            if (typeof me.onerror === \"function\") {\n                me.onerror(new ProgressEvent(\"error\", {\"target\":me}));\n            }\n\n            // If onwriteend callback\n            if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n            }\n        }, \"File\", \"truncate\", [this.localURL, size]);\n};\n\nmodule.exports = FileWriter;\n\n});\n"],"sourceRoot":"/source/"}