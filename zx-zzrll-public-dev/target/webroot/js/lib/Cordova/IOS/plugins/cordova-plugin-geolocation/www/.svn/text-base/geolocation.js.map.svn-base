{"version":3,"sources":["js/lib/Cordova/IOS/plugins/cordova-plugin-geolocation/www/geolocation.js"],"names":["cordova","define","require","exports","module","parseParameters","options","opt","maximumAge","enableHighAccuracy","timeout","Infinity","undefined","isNaN","createTimeout","errorCallback","t","setTimeout","clearTimeout","code","PositionError","TIMEOUT","message","argscheck","utils","exec","Position","timers","geolocation","lastPosition","getCurrentPosition","successCallback","checkArgs","arguments","timeoutTimer","timer","win","p","pos","latitude","longitude","altitude","accuracy","heading","velocity","altitudeAccuracy","timestamp","fail","e","err","Date","getTime","watchPosition","id","createUUID","clearWatch"],"mappings":"AAAAA,QAAQC,OAAO,yCAA0C,SAASC,EAASC,EAASC,GA+BpF,QAASC,GAAgBC,GACrB,GAAIC,IACAC,WAAY,EACZC,oBAAoB,EACpBC,QAASC,EAAAA,EAmBb,OAhBIL,KAC2BM,SAAvBN,EAAQE,aAA6BK,MAAMP,EAAQE,aAAeF,EAAQE,WAAa,IACvFD,EAAIC,WAAaF,EAAQE,YAEMI,SAA/BN,EAAQG,qBACRF,EAAIE,mBAAqBH,EAAQG,oBAEbG,SAApBN,EAAQI,SAA0BG,MAAMP,EAAQI,WAC5CJ,EAAQI,QAAU,EAClBH,EAAIG,QAAU,EAEdH,EAAIG,QAAUJ,EAAQI,UAK3BH,EAIX,QAASO,GAAcC,EAAeL,GAClC,GAAIM,GAAIC,WAAW,WACfC,aAAaF,GACbA,EAAI,KACJD,GACII,KAAKC,EAAcC,QACnBC,QAAQ,mCAEbZ,EACH,OAAOM,GA7CX,GAAIO,GAAYrB,EAAQ,qBACpBsB,EAAQtB,EAAQ,iBAChBuB,EAAOvB,EAAQ,gBACfkB,EAAgBlB,EAAQ,mBACxBwB,EAAWxB,EAAQ,cAEnByB,KA0CAC,GACAC,aAAa,KAQbC,mBAAmB,SAASC,EAAiBhB,EAAeT,GACxDiB,EAAUS,UAAU,MAAO,iCAAkCC,WAC7D3B,EAAUD,EAAgBC,EAI1B,IAAI4B,IAAgBC,MAAM,MAEtBC,EAAM,SAASC,GAEf,GADAnB,aAAagB,EAAaC,OACpBD,EAAkB,MAAxB,CAMA,GAAII,GAAM,GAAIZ,IAENa,SAASF,EAAEE,SACXC,UAAUH,EAAEG,UACZC,SAASJ,EAAEI,SACXC,SAASL,EAAEK,SACXC,QAAQN,EAAEM,QACVC,SAASP,EAAEO,SACXC,iBAAiBR,EAAEQ,kBAEvBR,EAAES,UAENlB,GAAYC,aAAeS,EAC3BP,EAAgBO,KAEhBS,EAAO,SAASC,GAChB9B,aAAagB,EAAaC,OAC1BD,EAAaC,MAAQ,IACrB,IAAIc,GAAM,GAAI7B,GAAc4B,EAAE7B,KAAM6B,EAAE1B,QAClCP,IACAA,EAAckC,GA6BtB,OAvBIrB,GAAYC,cAAgBvB,EAAQE,aAAgB,GAAK0C,OAAQC,UAAYvB,EAAYC,aAAaiB,WAAcxC,EAAQE,WAC5HuB,EAAgBH,EAAYC,cAED,IAApBvB,EAAQI,QACfqC,GACI5B,KAAKC,EAAcC,QACnBC,QAAQ,gLAIRhB,EAAQI,UAAYC,EAAAA,EAIpBuB,EAAaC,MAAQrB,EAAciC,EAAMzC,EAAQI,SAKjDwB,EAAaC,OAAQ,EAEzBV,EAAKW,EAAKW,EAAM,cAAe,eAAgBzC,EAAQG,mBAAoBH,EAAQE,cAEhF0B,GAWXkB,cAAc,SAASrB,EAAiBhB,EAAeT,GACnDiB,EAAUS,UAAU,MAAO,iCAAkCC,WAC7D3B,EAAUD,EAAgBC,EAE1B,IAAI+C,GAAK7B,EAAM8B,YAGf3B,GAAO0B,GAAMzB,EAAYE,mBAAmBC,EAAiBhB,EAAeT,EAE5E,IAAIyC,GAAO,SAASC,GAChB9B,aAAaS,EAAO0B,GAAIlB,MACxB,IAAIc,GAAM,GAAI7B,GAAc4B,EAAE7B,KAAM6B,EAAE1B,QAClCP,IACAA,EAAckC,IAIlBb,EAAM,SAASC,GACfnB,aAAaS,EAAO0B,GAAIlB,OACpB7B,EAAQI,UAAYC,EAAAA,IACpBgB,EAAO0B,GAAIlB,MAAQrB,EAAciC,EAAMzC,EAAQI,SAEnD,IAAI4B,GAAM,GAAIZ,IAENa,SAASF,EAAEE,SACXC,UAAUH,EAAEG,UACZC,SAASJ,EAAEI,SACXC,SAASL,EAAEK,SACXC,QAAQN,EAAEM,QACVC,SAASP,EAAEO,SACXC,iBAAiBR,EAAEQ,kBAEvBR,EAAES,UAENlB,GAAYC,aAAeS,EAC3BP,EAAgBO,GAKpB,OAFAb,GAAKW,EAAKW,EAAM,cAAe,YAAaM,EAAI/C,EAAQG,qBAEjD4C,GAOXE,WAAW,SAASF,GACZA,GAAqBzC,SAAfe,EAAO0B,KACbnC,aAAaS,EAAO0B,GAAIlB,OACxBR,EAAO0B,GAAIlB,OAAQ,EACnBV,EAAK,KAAM,KAAM,cAAe,cAAe4B,MAK3DjD,GAAOD,QAAUyB","file":"js/lib/Cordova/IOS/plugins/cordova-plugin-geolocation/www/geolocation.js","sourcesContent":["cordova.define(\"cordova-plugin-geolocation.geolocation\", function(require, exports, module) {\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    utils = require('cordova/utils'),\n    exec = require('cordova/exec'),\n    PositionError = require('./PositionError'),\n    Position = require('./Position');\n\nvar timers = {};   // list of timers in use\n\n// Returns default params, overrides if provided with values\nfunction parseParameters(options) {\n    var opt = {\n        maximumAge: 0,\n        enableHighAccuracy: false,\n        timeout: Infinity\n    };\n\n    if (options) {\n        if (options.maximumAge !== undefined && !isNaN(options.maximumAge) && options.maximumAge > 0) {\n            opt.maximumAge = options.maximumAge;\n        }\n        if (options.enableHighAccuracy !== undefined) {\n            opt.enableHighAccuracy = options.enableHighAccuracy;\n        }\n        if (options.timeout !== undefined && !isNaN(options.timeout)) {\n            if (options.timeout < 0) {\n                opt.timeout = 0;\n            } else {\n                opt.timeout = options.timeout;\n            }\n        }\n    }\n\n    return opt;\n}\n\n// Returns a timeout failure, closed over a specified timeout value and error callback.\nfunction createTimeout(errorCallback, timeout) {\n    var t = setTimeout(function() {\n        clearTimeout(t);\n        t = null;\n        errorCallback({\n            code:PositionError.TIMEOUT,\n            message:\"Position retrieval timed out.\"\n        });\n    }, timeout);\n    return t;\n}\n\nvar geolocation = {\n    lastPosition:null, // reference to last known (cached) position returned\n    /**\n   * Asynchronously acquires the current position.\n   *\n   * @param {Function} successCallback    The function to call when the position data is available\n   * @param {Function} errorCallback      The function to call when there is an error getting the heading position. (OPTIONAL)\n   * @param {PositionOptions} options     The options for getting the position data. (OPTIONAL)\n   */\n    getCurrentPosition:function(successCallback, errorCallback, options) {\n        argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);\n        options = parseParameters(options);\n\n        // Timer var that will fire an error callback if no position is retrieved from native\n        // before the \"timeout\" param provided expires\n        var timeoutTimer = {timer:null};\n\n        var win = function(p) {\n            clearTimeout(timeoutTimer.timer);\n            if (!(timeoutTimer.timer)) {\n                // Timeout already happened, or native fired error callback for\n                // this geo request.\n                // Don't continue with success callback.\n                return;\n            }\n            var pos = new Position(\n                {\n                    latitude:p.latitude,\n                    longitude:p.longitude,\n                    altitude:p.altitude,\n                    accuracy:p.accuracy,\n                    heading:p.heading,\n                    velocity:p.velocity,\n                    altitudeAccuracy:p.altitudeAccuracy\n                },\n                p.timestamp\n            );\n            geolocation.lastPosition = pos;\n            successCallback(pos);\n        };\n        var fail = function(e) {\n            clearTimeout(timeoutTimer.timer);\n            timeoutTimer.timer = null;\n            var err = new PositionError(e.code, e.message);\n            if (errorCallback) {\n                errorCallback(err);\n            }\n        };\n\n        // Check our cached position, if its timestamp difference with current time is less than the maximumAge, then just\n        // fire the success callback with the cached position.\n        if (geolocation.lastPosition && options.maximumAge && (((new Date()).getTime() - geolocation.lastPosition.timestamp) <= options.maximumAge)) {\n            successCallback(geolocation.lastPosition);\n        // If the cached position check failed and the timeout was set to 0, error out with a TIMEOUT error object.\n        } else if (options.timeout === 0) {\n            fail({\n                code:PositionError.TIMEOUT,\n                message:\"timeout value in PositionOptions set to 0 and no cached Position object available, or cached Position object's age exceeds provided PositionOptions' maximumAge parameter.\"\n            });\n        // Otherwise we have to call into native to retrieve a position.\n        } else {\n            if (options.timeout !== Infinity) {\n                // If the timeout value was not set to Infinity (default), then\n                // set up a timeout function that will fire the error callback\n                // if no successful position was retrieved before timeout expired.\n                timeoutTimer.timer = createTimeout(fail, options.timeout);\n            } else {\n                // This is here so the check in the win function doesn't mess stuff up\n                // may seem weird but this guarantees timeoutTimer is\n                // always truthy before we call into native\n                timeoutTimer.timer = true;\n            }\n            exec(win, fail, \"Geolocation\", \"getLocation\", [options.enableHighAccuracy, options.maximumAge]);\n        }\n        return timeoutTimer;\n    },\n    /**\n     * Asynchronously watches the geolocation for changes to geolocation.  When a change occurs,\n     * the successCallback is called with the new location.\n     *\n     * @param {Function} successCallback    The function to call each time the location data is available\n     * @param {Function} errorCallback      The function to call when there is an error getting the location data. (OPTIONAL)\n     * @param {PositionOptions} options     The options for getting the location data such as frequency. (OPTIONAL)\n     * @return String                       The watch id that must be passed to #clearWatch to stop watching.\n     */\n    watchPosition:function(successCallback, errorCallback, options) {\n        argscheck.checkArgs('fFO', 'geolocation.getCurrentPosition', arguments);\n        options = parseParameters(options);\n\n        var id = utils.createUUID();\n\n        // Tell device to get a position ASAP, and also retrieve a reference to the timeout timer generated in getCurrentPosition\n        timers[id] = geolocation.getCurrentPosition(successCallback, errorCallback, options);\n\n        var fail = function(e) {\n            clearTimeout(timers[id].timer);\n            var err = new PositionError(e.code, e.message);\n            if (errorCallback) {\n                errorCallback(err);\n            }\n        };\n\n        var win = function(p) {\n            clearTimeout(timers[id].timer);\n            if (options.timeout !== Infinity) {\n                timers[id].timer = createTimeout(fail, options.timeout);\n            }\n            var pos = new Position(\n                {\n                    latitude:p.latitude,\n                    longitude:p.longitude,\n                    altitude:p.altitude,\n                    accuracy:p.accuracy,\n                    heading:p.heading,\n                    velocity:p.velocity,\n                    altitudeAccuracy:p.altitudeAccuracy\n                },\n                p.timestamp\n            );\n            geolocation.lastPosition = pos;\n            successCallback(pos);\n        };\n\n        exec(win, fail, \"Geolocation\", \"addWatch\", [id, options.enableHighAccuracy]);\n\n        return id;\n    },\n    /**\n     * Clears the specified heading watch.\n     *\n     * @param {String} id       The ID of the watch returned from #watchPosition\n     */\n    clearWatch:function(id) {\n        if (id && timers[id] !== undefined) {\n            clearTimeout(timers[id].timer);\n            timers[id].timer = false;\n            exec(null, null, \"Geolocation\", \"clearWatch\", [id]);\n        }\n    }\n};\n\nmodule.exports = geolocation;\n\n});\n"],"sourceRoot":"/source/"}